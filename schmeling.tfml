<?xml version='1.0' encoding='utf-8'?>
<terraferma_options>
  <geometry>
    <dimension>
      <integer_value rank="0">2</integer_value>
    </dimension>
    <mesh name="Mesh">
      <source name="File">
        <file>
          <string_value type="filename" lines="1">square_refined_uni</string_value>
        </file>
        <cell>
          <string_value lines="1">triangle</string_value>
        </cell>
      </source>
    </mesh>
  </geometry>
  <io>
    <output_base_name>
      <string_value lines="1">rb_melt_convection</string_value>
    </output_base_name>
    <visualization>
      <element name="P2DG">
        <family>
          <string_value lines="1">DG</string_value>
        </family>
        <degree>
          <integer_value rank="0">2</integer_value>
        </degree>
      </element>
    </visualization>
    <dump_periods>
      <visualization_period>
        <real_value rank="0">25</real_value>
      </visualization_period>
      <statistics_period_in_timesteps>
        <integer_value rank="0">5</integer_value>
      </statistics_period_in_timesteps>
      <detectors_period>
        <real_value rank="0">50</real_value>
      </detectors_period>
    </dump_periods>
    <detectors>
      <point name="z_tbl">
        <real_value rank="1" dim1="dim" shape="2">0 0.9288025</real_value>
      </point>
      <array name="Array">
        <python>
          <string_value type="code" language="python3" lines="20">def val():
  from numpy import arange
  loc = [[0., y] for y in arange(0.0,1.0+1./1000.,1./100.)]
  return loc</string_value>
        </python>
      </array>
    </detectors>
    <checkpointing>
      <checkpoint_period>
        <real_value rank="0">100</real_value>
      </checkpoint_period>
    </checkpointing>
  </io>
  <timestepping>
    <current_time>
      <real_value rank="0">0</real_value>
    </current_time>
    <finish_time>
      <real_value rank="0">10000</real_value>
    </finish_time>
    <timestep>
      <coefficient name="Timestep">
        <ufl_symbol name="global">
          <string_value lines="1">dt</string_value>
        </ufl_symbol>
        <type name="Constant">
          <rank name="Scalar" rank="0">
            <value name="WholeMesh">
              <constant>
                <real_value rank="0">1.0e-3</real_value>
              </constant>
            </value>
          </rank>
        </type>
      </coefficient>
      <adaptive>
        <constraint name="Courant">
          <system name="CourantNumber"/>
          <field name="CourantNumber"/>
          <requested_maximum_value>
            <real_value rank="0">1</real_value>
          </requested_maximum_value>
        </constraint>
      </adaptive>
    </timestep>
    <steady_state>
      <tolerance>
        <real_value rank="0">1e-09</real_value>
      </tolerance>
    </steady_state>
  </timestepping>
  <global_parameters>
    <ufl>
      <string_value type="code" language="python3" lines="20"># Constant viscosities
eta = 1.
invzeta = 1.

# deviatoric stress tensor
edotd = sym(grad(v_i)) - div(v_i)*Identity(2)/3.
#edotd = sym(grad(v_i)) - div(v_i)*Identity(2)/2.
tau = 2.*eta*edotd

#dimensionless fluid density
rho_f = 0.9375
#rho_f = 1.5
drho = 1. - rho_f

#Inverse Ra number 
recRa = 1./Ra

# time-stepping parameters (theta=1.0, backwards euler, 0.5: crank nicholson)
theta = 0.5
theta_v = 0.5


# theta weighted parameters
v_theta = theta_v*v_i + (1. - theta_v)*v_n
vz_theta = theta_v*v_i[1] + (1. - theta_v)*v_n[1]
T_theta = theta*T_i + (1. - theta)*T_n
vT_i = (q_i + (1. - phi_i)*v_i)/(1. - phi_i*drho)
vT_n = (q_n + (1. - phi_n)*v_n)/(1. - phi_n*drho)
vT_theta = theta*vT_i + (1. - theta)*vT_n
vTz_i = (q_i[1] + (1. - phi_i)*v_i[1])/(1. - phi_i*drho)
vTz_n = (q_n[1] + (1. - phi_n)*v_n[1])/(1. - phi_n*drho)
vTz_theta = theta*vTz_i + (1. - theta)*vTz_n

#porosity and melting rate at a half-time step
phi_theta = 0.5*(phi_i + phi_n)
gamma_theta = 0.5*(gamma_i + gamma_n)
# depletion
fd_theta = 0.5*(fd_i + fd_n)

# Melting rate parameters
xc = SpatialCoordinate(gamma_e.cell())
Tsol = 0.4 + 0.65*(1 - xc[1])
# Material Derivative  of Temperature mixed solid-fluid frame
DTdt = (T_i - T_n)/dt + inner(vT_theta, grad(T_theta))

# Global parameters for porosity pressure residual 

# permeability
K = phi_i**n

#inverse bulk viscosity function
#Xi_i = hsquared*phi_i**m
#Xi_n = hsquared*phi_n**m
# m = 0
Xi_i = hsquared
Xi_n = hsquared 

# auxiliary variables of porosity residual
#outward facing facet normal for porosity cell
phin = FacetNormal(phi_e.cell())
# facet normal solid velocity
vn = dot(v_theta, phin)
# rectified normal solid velocity ( = vn if outflow, 0 if inflow)
vnout = 0.5*(vn + abs(vn))

# domains for assembly
# top of fluid region
ds_top   = ds(4)
ds_bottom = ds(3)
ds_left  = ds(1)
ds_right = ds(2)
ds_topfs = ds(4)</string_value>
    </ufl>
    <dolfin>
      <ghost_mode name="shared_facet"/>
    </dolfin>
  </global_parameters>
  <system name="Coupled">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">us</string_value>
    </ufl_symbol>
    <field name="Velocity">
      <ufl_symbol name="global">
        <string_value lines="1">v</string_value>
        <comment>Solid velocity</comment>
      </ufl_symbol>
      <type name="Function">
        <rank name="Vector" rank="1">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant name="dim">
              <real_value rank="1" dim1="dim" shape="2">0 0</real_value>
            </constant>
          </initial_condition>
          <boundary_condition name="LeftX">
            <boundary_ids>
              <integer_value rank="1" shape="1">1</integer_value>
            </boundary_ids>
            <sub_components name="X">
              <components>
                <integer_value rank="1" shape="1">0</integer_value>
              </components>
              <type name="Dirichlet" type="boundary_condition">
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </type>
            </sub_components>
          </boundary_condition>
          <boundary_condition name="RightX">
            <boundary_ids>
              <integer_value rank="1" shape="1">2</integer_value>
            </boundary_ids>
            <sub_components name="X">
              <components>
                <integer_value rank="1" shape="1">0</integer_value>
              </components>
              <type name="Dirichlet" type="boundary_condition">
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </type>
            </sub_components>
          </boundary_condition>
          <boundary_condition name="BottomY">
            <boundary_ids>
              <integer_value rank="1" shape="1">3</integer_value>
            </boundary_ids>
            <sub_components name="Y">
              <components>
                <integer_value rank="1" shape="1">1</integer_value>
              </components>
              <type name="Dirichlet" type="boundary_condition">
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </type>
            </sub_components>
          </boundary_condition>
          <boundary_condition name="TopY">
            <boundary_ids>
              <integer_value rank="1" shape="1">4</integer_value>
            </boundary_ids>
            <sub_components name="Y">
              <components>
                <integer_value rank="1" shape="1">1</integer_value>
              </components>
              <type name="Dirichlet" type="boundary_condition">
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </type>
            </sub_components>
          </boundary_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_steady_state>
          <norm>
            <string_value lines="1">linf</string_value>
          </norm>
        </include_in_steady_state>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <field name="Pressure">
      <ufl_symbol name="global">
        <string_value lines="1">p</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant>
              <real_value rank="0">0</real_value>
            </constant>
          </initial_condition>
          <reference_point name="Point">
            <coordinates>
              <real_value rank="1" dim1="dim" shape="2">0 0</real_value>
            </coordinates>
          </reference_point>
          <zero_point name="Point">
            <coordinates>
              <real_value rank="1" dim1="dim" shape="2">0 0</real_value>
            </coordinates>
          </zero_point>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
      </diagnostics>
    </field>
    <field name="Temperature">
      <ufl_symbol name="global">
        <string_value lines="1">T</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <cpp rank="0">
              <members>
                <string_value type="code" language="cpp" lines="20">double z1, z2;</string_value>
              </members>
              <initialization>
                <string_value type="code" language="cpp" lines="20">GenericFunction_ptr zi1_ptr, zi2_ptr;
zi1_ptr = system()-&gt;fetch_coeff("zi1")-&gt;genericfunction_ptr(time());
zi2_ptr = system()-&gt;fetch_coeff("zi2")-&gt;genericfunction_ptr(time());

z1 = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(zi1_ptr));
z2 = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(zi2_ptr));

std::cout &lt;&lt; "z1= " &lt;&lt; z1 &lt;&lt; " z2= " &lt;&lt; z2 &lt;&lt; '\n';</string_value>
              </initialization>
              <eval>
                <string_value type="code" language="cpp" lines="20">double z, Tzini;
const double pi = 3.141592653589793;

z = x[1];

if ( z &gt;= 0. &amp;&amp; z &lt;= z1)
{
  Tzini = 1. - 0.5*z/z1;
} else if ( z &gt; z1 &amp;&amp; z&lt;= z2 ) 
{
  Tzini = 0.5;
} else if ( z &gt; z2 &amp;&amp; z &lt;= 1.)
{
  Tzini = 0.5*(1. -  (z - z2)/(1. - z2) );
}
//std::cout &lt;&lt;  "z= " &lt;&lt; z &lt;&lt; " Tzini= " &lt;&lt; Tzini &lt;&lt;  " z1= " &lt;&lt; z1 &lt;&lt; " z2= " &lt;&lt; z2 &lt;&lt;'\n';
values[0] = (Tzini + 0.1*std::cos(x[0]*pi)*std::sin(z*pi));</string_value>
              </eval>
            </cpp>
          </initial_condition>
          <boundary_condition name="Top">
            <boundary_ids>
              <integer_value rank="1" shape="1">4</integer_value>
            </boundary_ids>
            <sub_components name="All">
              <type name="Dirichlet" type="boundary_condition">
                <constant>
                  <real_value rank="0">0</real_value>
                </constant>
              </type>
            </sub_components>
          </boundary_condition>
          <boundary_condition name="Bottom">
            <boundary_ids>
              <integer_value rank="1" shape="1">3</integer_value>
            </boundary_ids>
            <sub_components name="All">
              <type name="Dirichlet" type="boundary_condition">
                <constant>
                  <real_value rank="0">1</real_value>
                </constant>
              </type>
            </sub_components>
          </boundary_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_steady_state>
          <norm>
            <string_value lines="1">linf</string_value>
          </norm>
        </include_in_steady_state>
        <include_in_detectors/>
        <include_previous_timestep_in_visualization/>
      </diagnostics>
    </field>
    <field name="Gamma">
      <ufl_symbol name="global">
        <string_value lines="1">gamma</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1DG">
            <family>
              <string_value lines="1">DG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant>
              <real_value rank="0">0</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
      </diagnostics>
    </field>
    <field name="CompactionPressure">
      <ufl_symbol name="global">
        <string_value lines="1">pc</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant>
              <real_value rank="0">0</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
      <comment>Compaction pressure  p = Xi Div(V)</comment>
    </field>
    <field name="Porosity">
      <ufl_symbol name="global">
        <string_value lines="1">phi</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P2DG">
            <family>
              <string_value lines="1">DG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <python rank="0">
              <string_value type="code" language="python3" lines="20">def val(x):
  import random
  #uniform distribution in [0,1)
  #leave this x here even if you don't use it
  return random.uniform(0.0,0.3)</string_value>
            </python>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
      <comment>scaled porosity f = phi/phi_0</comment>
    </field>
    <field name="MeltFlux">
      <ufl_symbol name="global">
        <string_value lines="1">q</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Vector" rank="1">
          <element name="RT1">
            <family>
              <string_value lines="1">RT</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant name="dim">
              <real_value rank="1" dim1="dim" shape="2">0 0</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <field name="Depletion">
      <ufl_symbol name="global">
        <string_value lines="1">fd</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P2DG">
            <family>
              <string_value lines="1">DG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant>
              <real_value rank="0">0</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <field name="Height">
      <ufl_symbol name="global">
        <string_value lines="1">etah</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant>
              <real_value rank="0">0.0</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <coefficient name="Ra">
      <ufl_symbol name="global">
        <string_value lines="1">Ra</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">100000</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="Rm">
      <ufl_symbol name="global">
        <string_value lines="1">Rm</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">-1.5</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="Rd">
      <ufl_symbol name="global">
        <string_value lines="1">Rd</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1.48</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="invSt">
      <ufl_symbol name="global">
        <string_value lines="1">invSt</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.256016385048643</real_value>
              <comment>1./3.906</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="zi1">
      <ufl_symbol name="global">
        <string_value lines="1">zi1</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.047465</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
      <comment>first vertical position for temperature initial condition</comment>
    </coefficient>
    <coefficient name="zi2">
      <ufl_symbol name="global">
        <string_value lines="1">zi2</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.952535</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
      <comment>second vertical position for temperature initial condition</comment>
    </coefficient>
    <coefficient name="delta_f">
      <ufl_symbol name="global">
        <string_value lines="1">deltaf</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.01</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
      <comment>quadratic taper width for f</comment>
    </coefficient>
    <coefficient name="fgradf">
      <ufl_symbol name="global">
        <string_value lines="1">fgradf</string_value>
      </ufl_symbol>
      <type name="Expression">
        <rank name="Vector" rank="1">
          <element name="P2">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">2</integer_value>
            </degree>
            <size>
              <integer_value rank="0">3</integer_value>
            </size>
          </element>
          <value name="WholeMesh" type="value">
            <cpp rank="1">
              <members>
                <string_value type="code" language="cpp" lines="20">GenericFunction_ptr T_ptr;
double delta_f;</string_value>
              </members>
              <initialization>
                <string_value type="code" language="cpp" lines="20">T_ptr = system()-&gt;fetch_field("Temperature")-&gt;genericfunction_ptr(time());

GenericFunction_ptr delta_f_ptr;
delta_f_ptr = system()-&gt;fetch_coeff("delta_f")-&gt;genericfunction_ptr(time());

delta_f = double(*std::dynamic_pointer_cast&lt;dolfin::Constant&gt;(delta_f_ptr));</string_value>
              </initialization>
              <eval>
                <string_value type="code" language="cpp" lines="20">//set melting function constants
const double a = 0.4, b = 0.65;
const double deltaT_liq = 0.4;
const double c = std::sqrt(1. + b*b);
const double norm_gradf = c/deltaT_liq;
const double delta_r = delta_f/norm_gradf;
const double r_liquidus = deltaT_liq/c;

// set Tsolidus
double z = x[1];
double  Tsolidus = a + b*(1 - z);

// evaluate Temperature (T) at point x 
dolfin::Array&lt;double&gt; value(1);


T_ptr-&gt;eval(value, x, cell);
double T = value[0];

//set orthogonal distance r from the solidus
double r = (T - Tsolidus)/c;

double f,dfdT,dfdz;
if ( r &lt; - delta_r)
{
   f = 0.;
  dfdT = 0.;
  dfdz = 0.;

} 
else if ( r &gt;= -delta_r &amp;&amp; r &lt;= delta_r)
{
  f = norm_gradf/4./delta_r*(r + delta_r)*(r + delta_r);
  dfdT = norm_gradf*(r + delta_r)/2./delta_r/c;
  dfdz = b*dfdT;
}
else if ( r &gt; delta_r &amp;&amp; r  &lt;= r_liquidus)
{
  f = ( T -  Tsolidus)/deltaT_liq;
  dfdT = 1./deltaT_liq;
  dfdz = b*dfdT;
}
else if ( r &gt; r_liquidus )
{
  f = 1.;
  dfdT = 0.;
  dfdz = 0.;
} 
/* values[0] =  f; */
/* values[1] = dfdT; */
/* values[2] = dfdz; */
values[0]=0.0;
values[1]=0.0;
values[2]=0.0;</string_value>
                <comment>return degree of melting and partial derivatives with respect to (T,z)
really should be (T,P) but whatever</comment>
              </eval>
            </cpp>
          </value>
        </rank>
      </type>
      <diagnostics>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
      <comment>batch degree of melting</comment>
    </coefficient>
    <coefficient name="h_squared">
      <ufl_symbol name="global">
        <string_value lines="1">hsquared</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">1</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
      <comment>(h/delta)**2...   the system size in compacition lengths (delta) squared</comment>
    </coefficient>
    <coefficient name="FreezingRate">
      <ufl_symbol name="global">
        <string_value lines="1">R</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.0</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="n">
      <ufl_symbol name="global">
        <string_value lines="1">n</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">3</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
      <comment>exponent n in permeability K = phi**n</comment>
    </coefficient>
    <coefficient name="m">
      <ufl_symbol name="global">
        <string_value lines="1">m</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
      <comment>bulk viscosity exponent m,  such that the viscosity zeta = eta*phi^{- m}</comment>
    </coefficient>
    <coefficient name="ghat">
      <ufl_symbol name="global">
        <string_value lines="1">ghat</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Vector" rank="1">
          <value name="WholeMesh" type="value">
            <constant name="dim">
              <real_value rank="1" dim1="dim" shape="2">0 -1</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="epsilon">
      <ufl_symbol name="global">
        <string_value lines="1">epsilon</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.01</real_value>
              <comment>(thermal expansivity)*(Delta T)</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="UpUnit">
      <ufl_symbol name="global">
        <string_value lines="1">kup</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Vector" rank="1">
          <value name="WholeMesh" type="value">
            <constant name="dim">
              <real_value rank="1" dim1="dim" shape="2">0.0 1.0</real_value>
              <comment>upwards unit vector</comment>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <coefficient name="RhoExternal">
      <ufl_symbol name="global">
        <string_value lines="1">rhoe</string_value>
      </ufl_symbol>
      <type name="Constant">
        <rank name="Scalar" rank="0">
          <value name="WholeMesh" type="value">
            <constant>
              <real_value rank="0">0.0</real_value>
            </constant>
          </value>
        </rank>
      </type>
      <diagnostics/>
    </coefficient>
    <nonlinear_solver name="InitialSolve">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">Fv = (inner(sym(grad(v_t)) , tau) - div(v_t)*p_i)*dx
Fv += -v_t[1]*(T_i + Rm*fgradf[0] + Rd*fgradf[0]*(1. - fgradf[0]))*dx
Fp = p_t*(div(v_i) - pc_i*invzeta)*dx
FT= T_t*(T_i - T_n)*dx

F = FT + Fv + Fp</string_value>
          <comment>just update Temperature with previous velocity field (but do semi-implicit diffusion) as initial guess</comment>
          <ufl_symbol name="solver">
            <string_value lines="1">F</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J = derivative(F, us_i, us_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
          <ident_zeros/>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1e-07</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1e-08</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">5</integer_value>
        </max_iterations>
        <monitors>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="fgmres">
            <restart>
              <integer_value rank="0">30</integer_value>
            </restart>
            <relative_error>
              <real_value rank="0">1e-06</real_value>
            </relative_error>
            <absolute_error>
              <real_value rank="0">1e-11</real_value>
            </absolute_error>
            <max_iterations>
              <integer_value rank="0">100</integer_value>
            </max_iterations>
            <zero_initial_guess/>
            <monitors>
              <preconditioned_residual/>
            </monitors>
          </iterative_method>
          <preconditioner name="fieldsplit">
            <composite_type name="multiplicative"/>
            <fieldsplit name="Temperature">
              <field name="Temperature"/>
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="lu">
                  <factorization_package name="mumps"/>
                </preconditioner>
              </linear_solver>
            </fieldsplit>
            <fieldsplit name="Stokes">
              <field name="Pressure"/>
              <field name="Velocity"/>
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="lu">
                  <factorization_package name="mumps"/>
                </preconditioner>
              </linear_solver>
            </fieldsplit>
            <fieldsplit name="OtherVariables">
              <monitors/>
              <linear_solver>
                <iterative_method name="preonly"/>
                <preconditioner name="none"/>
              </linear_solver>
            </fieldsplit>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="at_start"/>
    </nonlinear_solver>
    <nonlinear_solver name="InitialGuess">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">#Melting Rate
gamma_p = rho_f*(fgradf[1]*DTdt + fgradf[2]*vTz_n)
gamma_sf = 0.5*(gamma_p + abs(gamma_p)) + 0.5*(gamma_p - abs(gamma_p))*phi_i
# reactive freezing rate
delta_Tsol = (T_i - Tsol)
gamma_freeze = phi_i*R*0.5*(delta_Tsol - abs(delta_Tsol))

FT = T_t*(1. + rho_f*invSt*fgradf[1])*(T_i - T_n + dt*inner(vT_n, grad(T_theta)))*dx
FT +=  T_t*dt*invSt*(rho_f*vTz_n*fgradf[2] + gamma_freeze)*dx
FT +=  dt*recRa*inner(grad(T_t), grad(T_theta))*dx

FG = gamma_t*(gamma_i - gamma_sf - gamma_freeze)*dx

# body integrals for porosity
bfm = phi_t*(phi_i - phi_n - dt*((1.-phi_n)*pc_n + gamma_theta))
# body integrals for advective integrals
bfa = - dt*dot(grad(phi_t), v_theta*phi_theta) - dt*phi_t*div(v_theta)*phi_theta

# all porosity body integrals
bf = bfm + bfa

# surface integrals over interior facets
upwindfacetflux = vnout('+')*phi_theta('+') - vnout('-')*phi_theta('-')
sffacet = dt*jump(phi_t)*upwindfacetflux

# porosity residual
Fphi =  bf*dx + sffacet*dS

# depletion residual
# body integrals for depletion
bfdm = fd_t*(fd_i - fd_n - dt*gamma_theta/rho_f)
# body integrals for advective integrals
bfda = - dt*dot(grad(fd_t), v_theta*fd_theta) - dt*fd_t*div(v_theta)*fd_theta

# all porosity body integrals
bfd = bfdm + bfda

# surface integrals over interior facets
upwindfacetflux_fd = vnout('+')*fd_theta('+') - vnout('-')*fd_theta('-')
sffacet_fd = dt*jump(fd_t)*upwindfacetflux_fd

# porosity residual
Fd =  bfd*dx + sffacet*dS
# total Residual
F = FT + FG + Fphi + Fd</string_value>
          <comment>just update Temperature with previous velocity field (but do semi-implicit diffusion) as initial guess</comment>
          <ufl_symbol name="solver">
            <string_value lines="1">F</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J = derivative(F, us_i, us_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
          <ident_zeros/>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_rule name="default"/>
        <snes_type name="vi">
          <constraints>
            <upper_bound>
              <field name="Porosity">
                <constant>
                  <real_value rank="0">1.0</real_value>
                </constant>
              </field>
              <monitors/>
            </upper_bound>
            <lower_bound>
              <field name="Porosity">
                <constant>
                  <real_value rank="0">0.0</real_value>
                </constant>
              </field>
              <monitors/>
            </lower_bound>
          </constraints>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1e-05</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1e-06</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">10</integer_value>
        </max_iterations>
        <monitors>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu">
            <factorization_package name="mumps"/>
          </preconditioner>
        </linear_solver>
        <ignore_all_solver_failures/>
      </type>
      <solve name="in_timeloop"/>
    </nonlinear_solver>
    <nonlinear_solver name="Solver">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">#Melting Rate
gamma_p = rho_f*(fgradf[1]*DTdt + fgradf[2]*vTz_theta)
gamma_sf = 0.5*(gamma_p + abs(gamma_p)) + 0.5*(gamma_p - abs(gamma_p))*phi_i
# reactive freezing rate
delta_Tsol = (T_i - Tsol)
gamma_freeze = phi_i*R*0.5*(delta_Tsol - abs(delta_Tsol))

#Free surface normal
un = FacetNormal(v_e.cell())

#First split is V,P,T
#Fv = (inner(sym(grad(v_t)), tau) - div(v_t)*p_i)*dx#original
#Fv += -v_t[1]*(T_i + Rm*phi_i + Rd*fd_i*(1. - phi_i))*dx#original
#Fp = p_t*(div(v_i) - invzeta*pc_i)*dx#original case

Fv = inner(sym(grad(v_t)), tau)*dx
Fv += -inner(v_t, un)*(p_i + ((rhoe-1.0)*epsilon + T_i + Rm*phi_i + Rd*fd_i*(1.0-phi_i))*etah_i)*ds_topfs
Fv += inner(v_t, grad(p_i))*dx
Fv += -v_t[1]*(T_i + Rm*phi_i + Rd*fd_i*(1. - phi_i))*dx
Fp = p_t*inner(v_i,un)*ds_topfs - inner(v_i, grad(p_t))*dx - p_t*pc_i*invzeta*dx
FT = T_t*(1. + rho_f*invSt*fgradf[1])*(T_i - T_n + dt*inner(vT_theta, grad(T_theta)))*dx
FT +=  T_t*dt*invSt*(rho_f*vTz_theta*fgradf[2] + gamma_freeze)*dx
FT +=  dt*recRa*inner(grad(T_t), grad(T_theta))*dx

# second split Gamma, phi, Pc
FG = gamma_t*(gamma_i - gamma_sf - gamma_freeze)*dx

#facet normal on compaction pressure
pcn=FacetNormal(pc_e.cell())

#surface integral terms from fluid flux, from Cian
#spctop = -pc_t*Xi_i*inner(v_i, pcn)*phi_i#top melt impermeable ==&gt; top free leaky surface (in bfb)
spcbot = -pc_t*K*inner((grad(p_i) + Rm*ghat),pcn)#grad(pc_i).pcn=0, #bottom permeable

# compaction pressure residual 
Fpc = inner(grad(pc_t), K*(grad(pc_i) + grad(p_i) + Rm*ghat))*dx
Fpc += pc_t*Xi_i*pc_i*dx + spcbot*ds_bottom# + spctop*ds_top 
#Fpc += - pc_t*Xi_i*Rm*gamma_i/rho_f*dx

# body integrals for porosity
pc_theta = 0.5*((1. - phi_i)*pc_i + (1. - phi_n)*pc_n)
bfm = phi_t*(phi_i - phi_n - dt*(pc_theta + gamma_theta))
# body integrals for advective integrals
bfa = - dt*dot(grad(phi_t), v_theta*phi_theta) - dt*phi_t*div(v_theta)*phi_theta

# all porosity body integrals
bf = bfm + bfa

# surface integrals over physical boundaries
bfb = dt*phi_t*phi_theta*0.5*(inner(v_theta, un) + abs(inner(v_theta, un)))

# surface integrals over interior facets
upwindfacetflux = vnout('+')*phi_theta('+') - vnout('-')*phi_theta('-')
sffacet = dt*jump(phi_t)*upwindfacetflux
# porosity residual
Fphi =  bf*dx + sffacet*dS + bfb*ds_topfs

# Almost last split melt flux
Fq = inner(q_t,(q_i - phi_i*v_i +  K/hsquared*(grad(pc_i) + grad(p_i)+ Rm*ghat)))*dx

# and depletion
# body integrals for depletion
bfdm = fd_t*(fd_i - fd_n - dt*gamma_theta/rho_f)
# body integrals for advective integrals
bfda = - dt*dot(grad(fd_t), v_theta*fd_theta) - dt*fd_t*div(v_theta)*fd_theta

# all depletion  body integrals
bfd = bfdm + bfda

# surface integrals over interior facets
upwindfacetflux_fd = vnout('+')*fd_theta('+') - vnout('-')*fd_theta('-')
sffacet_fd = dt*jump(fd_t)*upwindfacetflux_fd

# depletion residual
Fd =  bfd*dx + sffacet_fd*dS

#Surface motion residual
Fetah = etah_t*theta*((etah_i - etah_n)/dt)*inner(kup, un)*ds_topfs
Fetah += -etah_t*theta*inner(v_i, un)*ds_topfs

# total scary residual
F = Fv + Fp + FT + FG + Fpc + Fphi + Fq + Fd + Fetah</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">F</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J = derivative(F, us_i, us_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_rule name="default"/>
        <snes_type name="vi">
          <constraints>
            <upper_bound>
              <field name="Porosity">
                <constant>
                  <real_value rank="0">1.0</real_value>
                </constant>
              </field>
              <monitors/>
            </upper_bound>
            <lower_bound>
              <field name="Porosity">
                <constant>
                  <real_value rank="0">0.0</real_value>
                </constant>
              </field>
              <monitors/>
            </lower_bound>
          </constraints>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1e-07</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1e-09</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">50</integer_value>
        </max_iterations>
        <monitors>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="lu">
            <factorization_package name="mumps"/>
          </preconditioner>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="in_timeloop"/>
    </nonlinear_solver>
    <functional name="VelocityL2NormSquared">
      <string_value type="code" language="python3" lines="20">int = inner(v,v)*dx</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <include_in_statistics/>
    </functional>
    <functional name="TemperatureTopSurfaceIntegral">
      <string_value type="code" language="python3" lines="20">int = T.dx(1)*ds(4)</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <include_in_statistics/>
    </functional>
    <functional name="TemperatureBottomSurfaceIntegral">
      <string_value type="code" language="python3" lines="20">int = T.dx(1)*ds(3)</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <include_in_statistics/>
    </functional>
    <functional name="GammaIntegral">
      <string_value type="code" language="python3" lines="20">int = gamma_i*dx</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <include_in_statistics/>
    </functional>
    <functional name="CompactionPressureIntegral">
      <string_value type="code" language="python3" lines="20">int = pc*dx</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <include_in_statistics/>
    </functional>
    <functional name="PorosityBottomIntegral">
      <string_value type="code" language="python3" lines="20">#int = phi*dx
int = phi*ds(3)</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <include_in_statistics/>
    </functional>
    <functional name="PorosityIntegral">
      <string_value type="code" language="python3" lines="20">int = phi*dx</string_value>
      <ufl_symbol name="functional">
        <string_value lines="1">int</string_value>
      </ufl_symbol>
      <form_representation name="quadrature"/>
      <quadrature_rule name="default"/>
      <include_in_statistics/>
    </functional>
  </system>
  <system name="MeltVelocity">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">uvf</string_value>
    </ufl_symbol>
    <field name="MeltVelocity">
      <ufl_symbol name="global">
        <string_value lines="1">vf</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Vector" rank="1">
          <element name="RT1">
            <family>
              <string_value lines="1">RT</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant name="dim">
              <real_value rank="1" dim1="dim" shape="2">0 0</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
        <include_in_detectors/>
      </diagnostics>
    </field>
    <nonlinear_solver name="Solver">
      <type name="SNES">
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">F = inner(vf_t,(vf_i - v_i +  phi_i**(n-1)/hsquared*(grad(pc_i) + grad(p_i)+ Rm*ghat)))*dx</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">F</string_value>
          </ufl_symbol>
        </form>
        <form name="Jacobian" rank="1">
          <string_value type="code" language="python3" lines="20">J = derivative(F,uvf_i,uvf_a)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">J</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_rule name="default"/>
        <snes_type name="ls">
          <ls_type name="cubic"/>
          <convergence_test name="default"/>
        </snes_type>
        <relative_error>
          <real_value rank="0">1e-06</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1e-10</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">100</integer_value>
        </max_iterations>
        <monitors>
          <residual/>
        </monitors>
        <linear_solver>
          <iterative_method name="cg">
            <relative_error>
              <real_value rank="0">1e-07</real_value>
            </relative_error>
            <absolute_error>
              <real_value rank="0">1e-10</real_value>
            </absolute_error>
            <max_iterations>
              <integer_value rank="0">50</integer_value>
            </max_iterations>
            <zero_initial_guess/>
            <monitors>
              <preconditioned_residual/>
            </monitors>
          </iterative_method>
          <preconditioner name="sor"/>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="in_timeloop"/>
    </nonlinear_solver>
  </system>
  <system name="Divergence">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">ud</string_value>
    </ufl_symbol>
    <field name="Divergence">
      <ufl_symbol name="global">
        <string_value lines="1">d</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P1">
            <family>
              <string_value lines="1">CG</string_value>
            </family>
            <degree>
              <integer_value rank="0">1</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant>
              <real_value rank="0">0</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
      </diagnostics>
    </field>
    <nonlinear_solver name="Solver">
      <type name="Picard">
        <preamble>
          <string_value type="code" language="python3" lines="20">r = (d_t*d_a - d_t*div(v_i))*dx</string_value>
        </preamble>
        <form name="Bilinear" rank="1">
          <string_value type="code" language="python3" lines="20">a = lhs(r)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">a</string_value>
          </ufl_symbol>
        </form>
        <form name="Linear" rank="0">
          <string_value type="code" language="python3" lines="20">L = rhs(r)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">L</string_value>
          </ufl_symbol>
        </form>
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">res = action(a, ud_i) - L</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">res</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_rule name="default"/>
        <relative_error>
          <real_value rank="0">1e-06</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1e-10</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">1</integer_value>
        </max_iterations>
        <monitors/>
        <linear_solver>
          <iterative_method name="cg">
            <relative_error>
              <real_value rank="0">1e-06</real_value>
            </relative_error>
            <max_iterations>
              <integer_value rank="0">100</integer_value>
            </max_iterations>
            <nonzero_initial_guess/>
            <monitors>
              <preconditioned_residual/>
            </monitors>
          </iterative_method>
          <preconditioner name="sor"/>
          <monitors/>
        </linear_solver>
        <ignore_all_solver_failures/>
      </type>
      <solve name="with_diagnostics"/>
    </nonlinear_solver>
  </system>
  <system name="CourantNumber">
    <mesh name="Mesh"/>
    <ufl_symbol name="global">
      <string_value lines="1">uc</string_value>
    </ufl_symbol>
    <field name="CourantNumber">
      <ufl_symbol name="global">
        <string_value lines="1">c</string_value>
      </ufl_symbol>
      <type name="Function">
        <rank name="Scalar" rank="0">
          <element name="P0">
            <family>
              <string_value lines="1">DG</string_value>
            </family>
            <degree>
              <integer_value rank="0">0</integer_value>
            </degree>
          </element>
          <initial_condition name="WholeMesh" type="initial_condition">
            <constant>
              <real_value rank="0">0</real_value>
            </constant>
          </initial_condition>
        </rank>
      </type>
      <diagnostics>
        <include_in_visualization/>
        <include_in_statistics/>
      </diagnostics>
    </field>
    <nonlinear_solver name="Solver">
      <type name="Picard">
        <preamble>
          <string_value type="code" language="python3" lines="20">cn = FacetNormal(c_e.cell())
vn = dot(vf_i, cn)
vout = 0.5*(vn + abs(vn))

r = c_t*c_a*dx - c_t('+')*vout('+')*dt('+')*dS - c_t('-')*vout('-')*dt('-')*dS - c_t*vout*dt*ds(1) - c_t*vout*dt*ds(2) - c_t*vout*dt*ds(3) - c_t*vout*dt*ds(4)</string_value>
          <comment>set courant number with melt velocity</comment>
        </preamble>
        <form name="Bilinear" rank="1">
          <string_value type="code" language="python3" lines="20">a = lhs(r)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">a</string_value>
          </ufl_symbol>
        </form>
        <form name="Linear" rank="0">
          <string_value type="code" language="python3" lines="20">L = rhs(r)</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">L</string_value>
          </ufl_symbol>
        </form>
        <form name="Residual" rank="0">
          <string_value type="code" language="python3" lines="20">res = action(a, uc_i) - L</string_value>
          <ufl_symbol name="solver">
            <string_value lines="1">res</string_value>
          </ufl_symbol>
        </form>
        <form_representation name="quadrature"/>
        <quadrature_rule name="default"/>
        <relative_error>
          <real_value rank="0">1e-06</real_value>
        </relative_error>
        <absolute_error>
          <real_value rank="0">1e-16</real_value>
        </absolute_error>
        <max_iterations>
          <integer_value rank="0">1</integer_value>
        </max_iterations>
        <monitors/>
        <linear_solver>
          <iterative_method name="preonly"/>
          <preconditioner name="jacobi"/>
          <monitors/>
        </linear_solver>
        <never_ignore_solver_failures/>
      </type>
      <solve name="with_diagnostics"/>
    </nonlinear_solver>
  </system>
</terraferma_options>
